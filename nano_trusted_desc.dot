digraph {
	rankdir=LR;
	node [shape=plaintext];
	tooltip="A generic binary format for trusted descriptors (an info trusted by the nano signed by a Ledger key)
";
	subgraph cluster__nano_trusted_desc {
		label="NanoTrustedDesc";
		tooltip="A generic binary format for trusted descriptors (an info trusted by the nano signed by a Ledger key)
";
		graph[style=dotted];

		nano_trusted_desc__seq [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
			<TR><TD BGCOLOR="#E0FFE0">pos</TD><TD BGCOLOR="#E0FFE0">size</TD><TD BGCOLOR="#E0FFE0">type</TD><TD BGCOLOR="#E0FFE0">id</TD></TR>
			<TR><TD title="Type of the descriptor" href="" PORT="type_pos">0</TD><TD title="Type of the descriptor" href="" PORT="type_size">1</TD><TD title="Type of the descriptor" href="" >u1→DescType</TD><TD title="Type of the descriptor" href="" PORT="type_type">type</TD></TR>
			<TR><TD title="Version, currently fixed to 0x01" href="" PORT="version_pos">1</TD><TD title="Version, currently fixed to 0x01" href="" PORT="version_size">1</TD><TD title="Version, currently fixed to 0x01" href="" >bytes={0x01}</TD><TD title="Version, currently fixed to 0x01" href="" PORT="version_type">version</TD></TR>
			<TR><TD title="Signing key identifier, unique to Ledger. 
The corresponding certificate must be passed to the application before use.
" href="" PORT="key_pos">2</TD><TD title="Signing key identifier, unique to Ledger. 
The corresponding certificate must be passed to the application before use.
" href="" PORT="key_size">1</TD><TD title="Signing key identifier, unique to Ledger. 
The corresponding certificate must be passed to the application before use.
" href="" >u1→KeyEnum</TD><TD title="Signing key identifier, unique to Ledger. 
The corresponding certificate must be passed to the application before use.
" href="" PORT="key_type">key</TD></TR>
			<TR><TD title="An optional challenge to prove freshness of the descriptor" href="" PORT="challenge_pos">3</TD><TD title="An optional challenge to prove freshness of the descriptor" href="" PORT="challenge_size">...</TD><TD title="An optional challenge to prove freshness of the descriptor" href="" >Challenge</TD><TD title="An optional challenge to prove freshness of the descriptor" href="" PORT="challenge_type">challenge</TD></TR>
			<TR><TD title="Body of the descriptor, based on type" href="" PORT="body_pos">...</TD><TD title="Body of the descriptor, based on type" href="" PORT="body_size">...</TD><TD title="Body of the descriptor, based on type" href="" >switch (type)</TD><TD title="Body of the descriptor, based on type" href="" PORT="body_type">body</TD></TR>
			<TR><TD title="Signature of the descriptor computed over other fields" href="" PORT="sig_pos">...</TD><TD title="Signature of the descriptor computed over other fields" href="" PORT="sig_size">...</TD><TD title="Signature of the descriptor computed over other fields" href="" >Signature</TD><TD title="Signature of the descriptor computed over other fields" href="" PORT="sig_type">sig</TD></TR>
		</TABLE>>];
nano_trusted_desc__seq_body_switch [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
	<TR><TD BGCOLOR="#F0F2E4">case</TD><TD BGCOLOR="#F0F2E4">type</TD></TR>
	<TR><TD>:desc_type_plugin</TD><TD PORT="case0">PluginBody</TD></TR>
	<TR><TD>:desc_type_nft</TD><TD PORT="case1">NftBody</TD></TR>
	<TR><TD>:desc_type_name</TD><TD PORT="case2">NameBody</TD></TR>
</TABLE>>];
		subgraph cluster__nft_body {
			label="NanoTrustedDesc::NftBody";
			tooltip="An NFT collection descriptor";
			graph[style=dotted];

			nft_body__seq [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
				<TR><TD BGCOLOR="#E0FFE0">pos</TD><TD BGCOLOR="#E0FFE0">size</TD><TD BGCOLOR="#E0FFE0">type</TD><TD BGCOLOR="#E0FFE0">id</TD></TR>
				<TR><TD title="Length of the name field" href="" PORT="len_name_pos">0</TD><TD title="Length of the name field" href="" PORT="len_name_size">1</TD><TD title="Length of the name field" href="" >u1</TD><TD title="Length of the name field" href="" PORT="len_name_type">len_name</TD></TR>
				<TR><TD title="UTF-8 encoded name of the collection corresponding to the address" href="" PORT="name_pos">1</TD><TD title="UTF-8 encoded name of the collection corresponding to the address" href="" PORT="name_size">len_name</TD><TD title="UTF-8 encoded name of the collection corresponding to the address" href="" >bytes</TD><TD title="UTF-8 encoded name of the collection corresponding to the address" href="" PORT="name_type">name</TD></TR>
				<TR><TD title="Blockchain smartcontract address associated with this collection" href="" PORT="address_pos">...</TD><TD title="Blockchain smartcontract address associated with this collection" href="" PORT="address_size">20</TD><TD title="Blockchain smartcontract address associated with this collection" href="" >bytes</TD><TD title="Blockchain smartcontract address associated with this collection" href="" PORT="address_type">address</TD></TR>
				<TR><TD title="Blockchain id, as specified in XXX" href="" PORT="chain_id_pos">...</TD><TD title="Blockchain id, as specified in XXX" href="" PORT="chain_id_size">8</TD><TD title="Blockchain id, as specified in XXX" href="" >bytes</TD><TD title="Blockchain id, as specified in XXX" href="" PORT="chain_id_type">chain_id</TD></TR>
			</TABLE>>];
		}
		subgraph cluster__challenge {
			label="NanoTrustedDesc::Challenge";
			tooltip="An optional challenge enabling proving freshness of the descriptor";
			graph[style=dotted];

			challenge__seq [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
				<TR><TD BGCOLOR="#E0FFE0">pos</TD><TD BGCOLOR="#E0FFE0">size</TD><TD BGCOLOR="#E0FFE0">type</TD><TD BGCOLOR="#E0FFE0">id</TD></TR>
				<TR><TD title="length of the challenge, when no challenge is present use length of 0x00" href="" PORT="len_challenge_pos">0</TD><TD title="length of the challenge, when no challenge is present use length of 0x00" href="" PORT="len_challenge_size">1</TD><TD title="length of the challenge, when no challenge is present use length of 0x00" href="" >u1</TD><TD title="length of the challenge, when no challenge is present use length of 0x00" href="" PORT="len_challenge_type">len_challenge</TD></TR>
				<TR><TD title="challenge as an array of raw bytes" href="" PORT="challenge_pos">1</TD><TD title="challenge as an array of raw bytes" href="" PORT="challenge_size">len_challenge</TD><TD title="challenge as an array of raw bytes" href="" >bytes</TD><TD title="challenge as an array of raw bytes" href="" PORT="challenge_type">challenge</TD></TR>
			</TABLE>>];
		}
		subgraph cluster__plugin_body {
			label="NanoTrustedDesc::PluginBody";
			tooltip="A plugin descriptor";
			graph[style=dotted];

			plugin_body__seq [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
				<TR><TD BGCOLOR="#E0FFE0">pos</TD><TD BGCOLOR="#E0FFE0">size</TD><TD BGCOLOR="#E0FFE0">type</TD><TD BGCOLOR="#E0FFE0">id</TD></TR>
				<TR><TD title="Length of the name field" href="" PORT="len_name_pos">0</TD><TD title="Length of the name field" href="" PORT="len_name_size">1</TD><TD title="Length of the name field" href="" >u1</TD><TD title="Length of the name field" href="" PORT="len_name_type">len_name</TD></TR>
				<TR><TD title="ASCII encoded name of the plugin to use" href="" PORT="name_pos">1</TD><TD title="ASCII encoded name of the plugin to use" href="" PORT="name_size">len_name</TD><TD title="ASCII encoded name of the plugin to use" href="" >bytes</TD><TD title="ASCII encoded name of the plugin to use" href="" PORT="name_type">name</TD></TR>
				<TR><TD title="Blockchain smartcontract address associated with this plugin" href="" PORT="address_pos">...</TD><TD title="Blockchain smartcontract address associated with this plugin" href="" PORT="address_size">20</TD><TD title="Blockchain smartcontract address associated with this plugin" href="" >bytes</TD><TD title="Blockchain smartcontract address associated with this plugin" href="" PORT="address_type">address</TD></TR>
				<TR><TD title="function selector in the smartcontract associated with this plugin" href="" PORT="selector_pos">...</TD><TD title="function selector in the smartcontract associated with this plugin" href="" PORT="selector_size">4</TD><TD title="function selector in the smartcontract associated with this plugin" href="" >bytes</TD><TD title="function selector in the smartcontract associated with this plugin" href="" PORT="selector_type">selector</TD></TR>
				<TR><TD title="Blockchain id, as specified in XXX" href="" PORT="chain_id_pos">...</TD><TD title="Blockchain id, as specified in XXX" href="" PORT="chain_id_size">8</TD><TD title="Blockchain id, as specified in XXX" href="" >bytes</TD><TD title="Blockchain id, as specified in XXX" href="" PORT="chain_id_type">chain_id</TD></TR>
			</TABLE>>];
		}
		subgraph cluster__signature {
			label="NanoTrustedDesc::Signature";
			tooltip="a signature container";
			graph[style=dotted];

			signature__seq [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
				<TR><TD BGCOLOR="#E0FFE0">pos</TD><TD BGCOLOR="#E0FFE0">size</TD><TD BGCOLOR="#E0FFE0">type</TD><TD BGCOLOR="#E0FFE0">id</TD></TR>
				<TR><TD title="Signature length" href="" PORT="len_sig_pos">0</TD><TD title="Signature length" href="" PORT="len_sig_size">1</TD><TD title="Signature length" href="" >u1</TD><TD title="Signature length" href="" PORT="len_sig_type">len_sig</TD></TR>
				<TR><TD title="DER encoded signature.
Signature is computed over serialized fields [type , version , key , challenge , body].
Signature key and algorithm is determined by the [key] field and corresponding certificate.
" href="" PORT="sig_pos">1</TD><TD title="DER encoded signature.
Signature is computed over serialized fields [type , version , key , challenge , body].
Signature key and algorithm is determined by the [key] field and corresponding certificate.
" href="" PORT="sig_size">len_sig</TD><TD title="DER encoded signature.
Signature is computed over serialized fields [type , version , key , challenge , body].
Signature key and algorithm is determined by the [key] field and corresponding certificate.
" href="" >bytes</TD><TD title="DER encoded signature.
Signature is computed over serialized fields [type , version , key , challenge , body].
Signature key and algorithm is determined by the [key] field and corresponding certificate.
" href="" PORT="sig_type">sig</TD></TR>
			</TABLE>>];
		}
		subgraph cluster__name_body {
			label="NanoTrustedDesc::NameBody";
			tooltip="A trusted name descriptor";
			graph[style=dotted];

			name_body__seq [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
				<TR><TD BGCOLOR="#E0FFE0">pos</TD><TD BGCOLOR="#E0FFE0">size</TD><TD BGCOLOR="#E0FFE0">type</TD><TD BGCOLOR="#E0FFE0">id</TD></TR>
				<TR><TD title="Length of the name field" href="" PORT="len_name_pos">0</TD><TD title="Length of the name field" href="" PORT="len_name_size">1</TD><TD title="Length of the name field" href="" >u1</TD><TD title="Length of the name field" href="" PORT="len_name_type">len_name</TD></TR>
				<TR><TD title="UTF-8 encoded truted name associated with this address" href="" PORT="name_pos">1</TD><TD title="UTF-8 encoded truted name associated with this address" href="" PORT="name_size">len_name</TD><TD title="UTF-8 encoded truted name associated with this address" href="" >bytes</TD><TD title="UTF-8 encoded truted name associated with this address" href="" PORT="name_type">name</TD></TR>
				<TR><TD title="SLIP 44 coin type as in [https://github.com/ensdomains/address-encoder]" href="" PORT="coin_type_pos">...</TD><TD title="SLIP 44 coin type as in [https://github.com/ensdomains/address-encoder]" href="" PORT="coin_type_size">4</TD><TD title="SLIP 44 coin type as in [https://github.com/ensdomains/address-encoder]" href="" >bytes</TD><TD title="SLIP 44 coin type as in [https://github.com/ensdomains/address-encoder]" href="" PORT="coin_type_type">coin_type</TD></TR>
				<TR><TD title="Length of the address field" href="" PORT="len_address_pos">...</TD><TD title="Length of the address field" href="" PORT="len_address_size">1</TD><TD title="Length of the address field" href="" >u1</TD><TD title="Length of the address field" href="" PORT="len_address_type">len_address</TD></TR>
				<TR><TD title="Address value for this trusted name" href="" PORT="address_pos">...</TD><TD title="Address value for this trusted name" href="" PORT="address_size">len_address</TD><TD title="Address value for this trusted name" href="" >bytes</TD><TD title="Address value for this trusted name" href="" PORT="address_type">address</TD></TR>
			</TABLE>>];
		}
	}
	nano_trusted_desc__seq:challenge_type -> challenge__seq [style=bold];
	nano_trusted_desc__seq:body_type -> nano_trusted_desc__seq_body_switch [style=bold];
	nano_trusted_desc__seq_body_switch:case0 -> plugin_body__seq [style=bold];
	nano_trusted_desc__seq_body_switch:case1 -> nft_body__seq [style=bold];
	nano_trusted_desc__seq_body_switch:case2 -> name_body__seq [style=bold];
	nano_trusted_desc__seq:type_type -> nano_trusted_desc__seq:body_type [color="#404040"];
	nano_trusted_desc__seq:sig_type -> signature__seq [style=bold];
	nft_body__seq:len_name_type -> nft_body__seq:name_size [color="#404040"];
	challenge__seq:len_challenge_type -> challenge__seq:challenge_size [color="#404040"];
	plugin_body__seq:len_name_type -> plugin_body__seq:name_size [color="#404040"];
	signature__seq:len_sig_type -> signature__seq:sig_size [color="#404040"];
	name_body__seq:len_name_type -> name_body__seq:name_size [color="#404040"];
	name_body__seq:len_address_type -> name_body__seq:address_size [color="#404040"];
}
